/**
 * Common database helper functions.
 */
class DBHelper {

  /**
   * Database URL.
   * Change this to restaurants.json file location on your server.
   */
  static get DATABASE_URL() {
    const port = 1337 // Change this to your server port
    return `http://localhost:${port}`;
  }

  /**
   * Open database
   */
  static openDatabase() {
    return idb.open("withReviewDB", 4, function (upgradeDb) {
      switch (upgradeDb.oldVersion) {
        case 0:
          const restaurants = upgradeDb.createObjectStore('restaurants', {
            keyPath: 'id'
          });
          restaurants.createIndex('cuisine', 'cuisine_type');
          restaurants.createIndex('neighborhood', 'neighborhood');
        case 1:
          console.log("with reviews");
          const reviews = upgradeDb.createObjectStore('reviews', {
            keyPath: 'id'
          });
          reviews.createIndex('restaurant','restaurant_id');
        case 2:

          const offline_reviews = upgradeDb.createObjectStore('offline_reviews', {
            keyPath: 'id'
          });
      }
    });
  }


  /**
   * Get all restaurants
   * Updates locally cached restaurants if list is empty

   */
  static getRestaurants() {
    return new Promise((resolve,reject) => {

      DBHelper.openDatabase().then(db => {
        let tx = db.transaction('restaurants');
        let store = tx.objectStore('restaurants');
        store.getAll().then(restaurants => {
          if (restaurants && restaurants.length > 0) {
            resolve(restaurants);
          } else {
            DBHelper.updateRestaurants().then(listFromUrl => {
              resolve(listFromUrl);
            }).catch(reject);
          }
        });
      }).catch(reject);
    });
  }

  /**
   * Get offline-first reviews and updates reviews from server if list is empty
   */
  static getReviews(restaurantId) {
    return new Promise((resolve,reject) => {

      DBHelper.openDatabase().then(db => {
        let tx = db.transaction('reviews');
        let store = tx.objectStore('reviews').index('restaurant');
        store.getAll(restaurantId).then(result => {
          if (result && result.length > 0) {
            resolve(result);
          } else {
            DBHelper.updateReviews(restaurantId).then(listFromUrl => {
              resolve(listFromUrl);
            }).catch(reject);
          }
        });
      }).catch(reject);
    });
  }

  /**
 * Update locally cached reviews for restaurant
 */
static updateReviews(restaurantId) {
  return new Promise((resolve,reject) => {
    fetch(DBHelper.DATABASE_URL + '/reviews?restaurant_id=' + restaurantId)
    .then(response => {
      response.json()
      .then(data => {
        DBHelper.openDatabase()
        .then(db => {
          var tx = db.transaction("reviews", "readwrite");
          var store = tx.objectStore("reviews");
          data.forEach(element => {
            element.restaurant_id = parseInt(element.restaurant_id);
            element.rating = parseInt(element.rating);
            store.put(element);
          });
        });
        var event = new CustomEvent("reviews_updated", {detail: {restaurant_id: restaurantId}});
        document.dispatchEvent(event);
        return resolve(data);
      });
    });

  })
}

/**
 * Save a review to the offline cache
 */
static storeOfflineReview(review) {
  DBHelper.openDatabase().then(db => {
    var tx = db.transaction("offline_reviews","readwrite");
    var store = tx.objectStore("offline_reviews");
    store.add({id: Date.now(), data: review});
  })
}

/**
* Get reviews stored while offline
*/
static getOfflineReviews() {
  return new Promise((resolve,reject) => {
    DBHelper.openDatabase().then(db => {
      var tx = db.transaction("offline_reviews");
      var store = tx.objectStore("offline_reviews");
      store.getAll().then(data => {
        return resolve(data);
      }).catch(e => {
        reject(e);
      });
    })
  })
}
/**
* Delete new locally stored reviews
*/
static clearOfflineReviews() {
  return new Promise((resolve, reject) => {
    DBHelper.openDatabase().then(db => {
      var tx = db.transaction("offline_reviews", "readwrite");
      tx.objectStore("offline_reviews").clear();
      return resolve();
    }).catch(reject);
  });
}

/**
 * Update offline restaurants from database
 */
static updateRestaurants() {
  return new Promise((resolve,reject) => {
    fetch(DBHelper.DATABASE_URL + '/restaurants')
    .then(response => {
      response.json()
      .then(restaurants => {
        DBHelper.openDatabase()
        .then(db => {
          var tx = db.transaction("restaurants", "readwrite");
          var store = tx.objectStore("restaurants");
          restaurants.forEach(element => {
            store.put(element);
          });
        });
        DBHelper.updateReviews();
        return resolve(restaurants);
      });
    });

  })

}

  /**
   * Fetch a restaurant by its ID.
   */
  static fetchRestaurantById(id, callback) {
    // fetch all restaurants with proper error handling.
    DBHelper.openDatabase()
    .then(db => {
      let tx = db.transaction('restaurants');
      let store = tx.objectStore('restaurants');
      store.get(parseInt(id))
      .then(result => {
        callback(null,result);
      }).catch((e) => {
        callback(e,null)
      });
    });
  }

/**
 * Get the locally cached reviews for restaurant
 */
static fetchReviewsForRestaurantId(id) {
    return new Promise((resolve, reject) => {
      DBHelper.openDatabase()
      .then(db => {
        let tx = db.transaction('reviews');
        let store = tx.objectStore('reviews').index('restaurant');
        return store.getAll(parseInt(id))
      .then(resolve)
      .catch((e) => {
        console.error('Could not get reviews for Restaurant', e);
        resolve([]);
      });
      });
    });
  }

  /**
   * Fetch restaurants by a cuisine type with proper error handling.
   */
  static fetchRestaurantByCuisine(cuisine, callback) {
    DBHelper.openDatabase().then(db => {
      let tx = db.transaction('restaurants');
      let store = tx.objectStore('restaurants').index('cuisine');
      return store.get(cuisine);
    }).then(result => {
      callback(null,result);
    }).catch((e) => {
      callback(e,null)
    });
  }

  /**
   * Fetch restaurants by a neighborhood with proper error handling.
   */
  static fetchRestaurantByNeighborhood(neighborhood, callback) {
    // Fetch all restaurants
    DBHelper.openDatabase().then(db => {
      let tx = db.transaction('restaurants');
      let store = tx.objectStore('restaurants').index('neighborhood');
      return store.get(neighborhood);
    }).then(result => {
      callback(null,result);
    }).catch((e) => {
      callback(e,null)
    });
  }

  /**
   * Fetch restaurants by a cuisine and a neighborhood with proper error handling.
   */
  static fetchRestaurantByCuisineAndNeighborhood(cuisine, neighborhood, callback) {
    // Fetch all restaurants
    DBHelper.getRestaurants().then(results => {
      if (cuisine != 'all') { // filter by cuisine
        results = results.filter(r => r.cuisine_type == cuisine);
      }
      if (neighborhood != 'all') { // filter by neighborhood
        results = results.filter(r => r.neighborhood == neighborhood);
      }
      callback(null,results);
    }).catch((e) => {
      callback(e,null)
    });
  }

  /**
   * Fetch all neighborhoods with proper error handling.
   */
  static fetchNeighborhoods(callback) {
    // Fetch all restaurants
    DBHelper.getRestaurants().then(result => {
      // Get all neighborhoods from all restaurants
      const neighborhoods = result.map((v, i) => result[i].neighborhood)
      // Remove duplicates from neighborhoods
      const uniqueNeighborhoods = neighborhoods.filter((v, i) => neighborhoods.indexOf(v) == i)
      callback(null, uniqueNeighborhoods);
    });
  }

  /**
   * Fetch all cuisines with proper error handling.
   */
  static fetchCuisines(callback) {
    // Fetch all restaurants
    DBHelper.getRestaurants().then(result => {
        // Get all cuisines from all restaurants
        const cuisines = result.map((v, i) => result[i].cuisine_type)
        // Remove duplicates from cuisines
        const uniqueCuisines = cuisines.filter((v, i) => cuisines.indexOf(v) == i)
        callback(null, uniqueCuisines);
    });
  }

  /**
   * Restaurant page URL.
   */
  static urlForRestaurant(restaurant) {
    return (`./restaurant.html?id=${restaurant.id}`);
  }

  /**
   * Restaurant image URL.
   */

  static imageUrlForRestaurant(restaurant) {
    if (restaurant.photograph) {
      return (`/img/${restaurant.photograph}.jpg`);
    } else {
      return (`/img/${restaurant.id}.jpg`);
    }
  }
  static smallImageUrlForRestaurant(restaurant) {
    if (restaurant.photograph) {
      return (`/img/small-${restaurant.photograph}.jpg`);
    } else {
      return (`/img/small-${restaurant.id}.jpg`);
    }
  }

  /**
   * Map marker for a restaurant.
   */
  static mapMarkerForRestaurant(restaurant, map) {
    const marker = new google.maps.Marker({
      position: restaurant.latlng,
      title: restaurant.name,
      url: DBHelper.urlForRestaurant(restaurant),
      map: map,
      animation: google.maps.Animation.DROP
    });
    return marker;
  }

} //end of DBHELPER